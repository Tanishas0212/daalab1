
}
Horspool's algorithm
#include <stdio.h>
#include <string.h>

#define MAX_CHAR 256

// Function to precompute the bad character heuristic table
void badCharHeuristic(char* pattern, int patternLength, int badChar[MAX_CHAR]) {
    for (int i = 0; i < MAX_CHAR; i++) {
        badChar[i] = -1;
    }

    for (int i = 0; i < patternLength; i++) {
        badChar[(int)pattern[i]] = i;
    }
}

// Function to perform Horspool's string matching
void horspoolStringMatch(char* text, char* pattern) {
    int textLength = strlen(text);
    int patternLength = strlen(pattern);

    int badChar[MAX_CHAR];
    badCharHeuristic(pattern, patternLength, badChar);

    int shift = 0;

    while (shift <= textLength - patternLength) {
        int j = patternLength - 1;

        while (j >= 0 && patt…
Traveling Salesman Problem (TSP)
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX_CITIES 100

// Structure to represent a city with (x, y) coordinates
struct City {
    int x, y;
};

// Function to calculate the Euclidean distance between two cities
double distance(struct City city1, struct City city2) {
    return sqrt(pow(city1.x - city2.x, 2) + pow(city1.y - city2.y, 2));
}

// Function to find the nearest neighbor of a city
int findNearestNeighbor(int currentCity, int numCities, struct City cities[], int visited[]) {
    int nearestCity = -1;
    double minDistance = -1;

    for (int i = 0; i < numCities; i++) {
        if (!visited[i] && (nearestCity == -1 || distance(cities[currentCity], cities[i]) < minDistance)) {
            nearestCity = i;
            minDis…
Bellman-Ford algorithm
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX_VERTICES 100
#define MAX_EDGES 100

struct Edge {
    int source, destination, weight;
};

struct Graph {
    int numVertices, numEdges;
    struct Edge edges[MAX_EDGES];
};

void bellmanFord(struct Graph* graph, int source) {
    int numVertices = graph->numVertices;
    int numEdges = graph->numEdges;
    int distance[MAX_VERTICES];

    // Initialize distances from the source to all vertices as infinity
    for (int i = 0; i < numVertices; i++) {
        distance[i] = INT_MAX;
    }

    // Set the distance to the source vertex to 0
    distance[source] = 0;

    // Relax all edges repeatedly to find the shortest path
    for (int i = 0; i < numVertices - 1; i++) {
        for (int j …
Prim's algorithm
#include <stdio.h>
#include <stdbool.h>
#include <limits.h>

#define MAX_VERTICES 100

// Structure to represent an edge in the graph
struct Edge {
    int source, destination, weight;
};

// Structure to represent a graph
struct Graph {
    int numVertices, numEdges;
    struct Edge edges[MAX_VERTICES];
};

void primMST(struct Graph* graph) {
    int numVertices = graph->numVertices;
    int parent[MAX_VERTICES]; // Array to store the parent of each vertex in the MST
    int key[MAX_VERTICES];    // Array to store the key values of vertices
    bool inMST[MAX_VERTICES]; // Array to track whether a vertex is in the MST

    // Initialize key values and inMST flags
    for (int i = 0; i < numVertices; i++) {
        key[i] = INT_MAX;
        inMST[i] = false;…
